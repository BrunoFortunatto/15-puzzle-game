<!DOCTYPE html>
<html lang="pt">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>15 Puzzle Game</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            background-color: #f5f5f5;
            font-family: Arial, sans-serif;
            padding-top: 30px;
            box-sizing: border-box;
            margin: 0;
        }

        body.dark-mode {
            background-color: #121212;
            color: #ffffff;
        }

        body.dark-mode .title {
            color: #ffffff;
        }

        body.dark-mode .btn {
            background-color: #333333;
            color: #ffffff;
        }

        body.dark-mode .btn:hover {
            background-color: #555555;
        }

        body.dark-mode .game-container {
            background-color: #121212;
            /* Fundo s√≥lido para o container do jogo */
            border-radius: 10px;
            /* Opcional: bordas arredondadas */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            /* Sombra para destaque */
        }

        body.dark-mode .tile {
            background-color: #333333;
            color: #ffffff;
        }

        body.dark-mode .tile.correct-position {
            background-color: #444444;
            color: #ffffff;
        }

        body.dark-mode .empty {
            background-color: #1e1e1e;
        }

        body.dark-mode .win-message {
            background-color: #333333;
            color: #ffffff;
        }

        body.dark-mode .developer-info {
            background-color: rgba(255, 255, 255, 0.8);
            color: #000000;
        }

        body.dark-mode .scoreboard-container {
            background-color: #1e1e1e;
            /* Fundo escuro para o painel */
            color: #ffffff;
            /* Texto claro */
            border-radius: 10px;
            /* Bordas arredondadas */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            /* Sombra para destaque */
        }

        body.dark-mode .scoreboard-column h3 {
            color: #ffffff;
        }

        body.dark-mode .scoreboard-column div {
            color: #cccccc;
        }

        body.dark-mode .scoreboard-column strong {
            color: #ffcc00;
            /* Destaque para os melhores resultados */
        }

        body.dark-mode .scoreboard-columns {
            background-color: #2a2a2a;
            /* Fundo escuro para as colunas */
            color: #ffffff;
            /* Texto claro */
            border-radius: 10px;
            /* Bordas arredondadas */
            padding: 10px;
            /* Espa√ßamento interno */
        }

        body.dark-mode .scoreboard-column {
            background-color: #333333;
            /* Fundo individual das colunas */
            color: #ffffff;
            /* Texto claro */
            border-radius: 5px;
            /* Bordas arredondadas */
            padding: 10px;
            /* Espa√ßamento interno */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
            /* Sombra para destaque */
        }

        body.dark-mode .board {
            background-color: #1e1e1e;
            /* Fundo s√≥lido para o tabuleiro */
            border-radius: 10px;
            /* Opcional: bordas arredondadas */
        }

        .title {
            font-family: 'Press Start 2P', cursive;
            font-size: 24px;
            color: #002147;
            margin-bottom: 15px;
            text-align: center;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 10px;
        }

        .btn {
            background-color: #002147;
            color: #fff;
            font-size: 16px;
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            text-align: center;
            min-width: 110px;
            /* Largura m√≠nima original */
            width: auto;
            /* Garante que a largura se ajuste ao conte√∫do, mas n√£o menos que min-width */
        }

        .btn:hover {
            background-color: #004080;
        }

        .status-container {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 15px;
            margin-bottom: 20px;
            font-size: 16px;
            align-items: center;
        }

        .icon {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        #moveCounter,
        #timer {
            min-width: 90px;
            text-align: center;
            display: inline-block;
        }

        .main-container {
            display: flex;
            align-items: flex-start;
            gap: 40px;
            margin-top: 20px;
        }

        .game-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 600px;
            height: 600px;
            margin-top: -60px;
            /* Move o tabuleiro para cima */
            position: relative;
            /* Mant√©m o controle sem remover do fluxo */
        }

        .board {
            display: grid;
            gap: 4px;
            background-color: #002147;
            padding: 10px;
            border-radius: 10px;
        }

        .tile {
            width: 70px;
            height: 70px;
            background-color: #ffffff;
            color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.15s ease-in-out;
        }

        .tile:hover {
            filter: brightness(90%);
            cursor: pointer;
        }

        .empty {
            background-color: #002147;
            color: transparent;
            cursor: default;
        }

        .paused {
            pointer-events: none;
        }

        .win-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0s linear 0.3s;
        }

        .win-message {
            background-color: #fff;
            color: #002147;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            font-size: 18px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-50px);
            opacity: 0;
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
        }

        .win-overlay.active {
            opacity: 1;
            visibility: visible;
            transition-delay: 0s;
        }

        .win-overlay.active .win-message {
            transform: translateY(0);
            opacity: 1;
            transition-delay: 0.2s;
        }

        .win-message h2 {
            font-family: 'Press Start 2P', cursive;
            font-size: 24px;
            margin-bottom: 12px;
        }

        .win-message p {
            margin-bottom: 8px;
        }

        .play-again-btn {
            background-color: #004080;
            color: #fff;
            font-size: 16px;
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 15px;
        }

        .play-again-btn:hover {
            background-color: #0059b3;
        }

        .tile.correct-position {
            background-color: gold;
            color: black;
        }

        .scoreboard-container {
            text-align: center;
            width: 600px;
            margin-left: 50px;
            /* Adicionado margin-left para mover para a direita */
        }

        .scoreboard-columns {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            /* Cria 3 colunas de largura igual */
            gap: 10px;
            /* Espa√ßamento entre as colunas */
            background-color: #ddd;
            padding: 20px;
            /* Espa√ßamento interno geral */
            border-radius: 10px;
            align-items: start;
            /* Alinha os itens no topo das c√©lulas da grade */
        }

        .scoreboard-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            /* Centraliza os itens horizontalmente */
            text-align: center;
            /* Centraliza o texto dentro da coluna */
        }

        .scoreboard-column h3 {
            font-size: 18px;
            color: #333;
            margin-bottom: 10px;
        }

        .scoreboard-column div {
            font-size: 14px;
            color: #555;
            margin-bottom: 5px;
            /* Espa√ßamento entre os divs (movimentos e tempos) */
        }

        .scoreboard-column strong {
            font-weight: bold;
            color: #004080;
        }

        .developer-info {
            background-color: rgba(0, 33, 71, 0.8);
            font-size: 14px;
            position: absolute;
            color: #fff;
            top: 10px;
            right: 10px;
            font-family: 'Arial', sans-serif;
            padding: 8px 12px;
            border-radius: 5px;
            z-index: 1000;
            opacity: 0.8;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
        }

        .theme-toggle-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: #002147;
            color: #fff;
            font-size: 14px;
            padding: 8px 12px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
        }

        .theme-toggle-btn:hover {
            background-color: #004080;
        }
    </style>
</head>

<body>
    <button class="btn theme-toggle-btn" onclick="toggleDarkMode()">Modo Escuro</button>
    <div class="developer-info">
        Desenvolvido por Bruno Fortunato
    </div>

    <div class="title">15 Puzzle Game</div>
    <div class="controls">
        <button class="btn" onclick="confirmChange(3)">3x3</button>
        <button class="btn" onclick="confirmChange(4)">4x4</button>
        <button class="btn" onclick="confirmChange(5)">5x5</button>
    </div>
    <div class="controls">
        <button class="btn" id="pauseBtn" onclick="togglePause()">Pausa</button>
        <button class="btn" onclick="confirmRestart()">Reiniciar</button>
    </div>

    <div class="status-container">
        <div class="icon">
            üèÅ <span id="moveCounter">0</span>
        </div>
        <div class="icon">
            ‚è≥ <span id="timer">00:00:000</span>
        </div>
    </div>

    <div class="main-container">
        <div class="game-container">
            <div class="board" id="board"></div>
        </div>
        <div class="scoreboard-container">
            <h2>Placar dos Melhores Resultados</h2>
            <div class="scoreboard-columns">
                <div class="scoreboard-column">
                    <h3>3x3</h3>
                    <div id="scoreboard-3x3-moves"></div>
                    <div id="scoreboard-3x3-time"></div>
                </div>
                <div class="scoreboard-column">
                    <h3>4x4</h3>
                    <div id="scoreboard-4x4-moves"></div>
                    <div id="scoreboard-4x4-time"></div>
                </div>
                <div class="scoreboard-column">
                    <h3>5x5</h3>
                    <div id="scoreboard-5x5-moves"></div>
                    <div id="scoreboard-5x5-time"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let isPaused = false;
        let currentSize = 4; // Tamanho padr√£o do tabuleiro
        let moveCount = 0;
        let startTime;
        let timerInterval;
        let gameStarted = false;
        let tilesArray = [];
        let gameWon = false; // Adicionando a flag de vit√≥ria

        const SCOREBOARD_KEY = 'puzzle15Scoreboard';

        function saveScore(size, moves, time) {
            try {
                let scoreboard = getScoreboard();
                const gameType = `${size}x${size}`; // Corrigido para usar template literals

                if (!scoreboard[gameType]) {
                    scoreboard[gameType] = { moves: [], times: [] };
                }

                scoreboard[gameType].moves.push(moves);
                scoreboard[gameType].moves.sort((a, b) => a - b);
                if (scoreboard[gameType].moves.length > 5) {
                    scoreboard[gameType].moves.pop();
                }

                const timeInMilliseconds = timeToMilliseconds(time);
                scoreboard[gameType].times.push(timeInMilliseconds);
                scoreboard[gameType].times.sort((a, b) => a - b);
                if (scoreboard[gameType].times.length > 5) {
                    scoreboard[gameType].times.pop();
                }

                localStorage.setItem(SCOREBOARD_KEY, JSON.stringify(scoreboard));
                updateScoreboardDisplay();
            } catch (error) {
                console.error("Erro ao salvar o placar:", error);
            }
        }

        function getScoreboard() {
            const storedScoreboard = localStorage.getItem(SCOREBOARD_KEY);
            return storedScoreboard ? JSON.parse(storedScoreboard) : {};
        }

        function updateScoreboardDisplay() {
            console.log('Dados do placar:', getScoreboard());
            const scoreboardData = getScoreboard();
            [3, 4, 5].forEach(size => {
                const gameType = `${size}x${size}`;
                const movesContainer = document.getElementById(`scoreboard-${size}x${size}-moves`);
                const timesContainer = document.getElementById(`scoreboard-${size}x${size}-time`);

                if (movesContainer) {
                    movesContainer.innerHTML = "<strong>Melhores Movimentos:</strong><br>";
                    if (scoreboardData[gameType]?.moves) {
                        scoreboardData[gameType].moves.forEach(moves => {
                            movesContainer.innerHTML += `${moves} movimentos<br>`;
                        });
                    }
                }

                if (timesContainer) {
                    timesContainer.innerHTML = "<strong>Melhores Tempos:</strong><br>";
                    if (scoreboardData[gameType]?.times) {
                        scoreboardData[gameType].times.forEach(time => {
                            timesContainer.innerHTML += `${millisecondsToTime(time)}<br>`;
                        });
                    }
                }
            });
        }

        function timeToMilliseconds(timeString) {
            const [minutes, seconds, milliseconds] = timeString.split(':').map(Number);
            return (minutes * 60 + seconds) * 1000 + milliseconds;
        }

        function millisecondsToTime(totalMilliseconds) {
            const totalSeconds = Math.floor(totalMilliseconds / 1000);
            const minutes = String(Math.floor(totalSeconds / 60)).padStart(2, "0");
            const seconds = String(totalSeconds % 60).padStart(2, "0");
            const milliseconds = String(totalMilliseconds % 1000).padStart(3, "0");
            return `${minutes}:${seconds}:${milliseconds}`;
        }

        function generateBoard(size) {
            const board = document.getElementById("board");
            if (!board) {
                console.error("Elemento 'board' n√£o encontrado.");
                return;
            }
            currentSize = size;
            moveCount = 0;
            gameStarted = false;
            isPaused = false;
            gameWon = false; // Reinicia a flag de vit√≥ria
            document.getElementById("moveCounter").textContent = moveCount;
            resetTimer();

            board.innerHTML = "";
            board.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
            board.style.width = `${size * 74}px`;
            board.style.height = `${size * 74}px`;
            board.classList.remove("paused", "game-over"); // Remove as classes
            board.removeEventListener('click', handleTileClick); // Remove listener antigo
            board.addEventListener('click', handleTileClick); // Adiciona listener

            const pauseBtn = document.getElementById("pauseBtn");
            pauseBtn.textContent = "Pausa";

            tilesArray = Array.from({ length: size * size - 1 }, (_, i) => String(i + 1));
            tilesArray.push("");
            renderBoard();
            setTimeout(shuffleBoard, 100);
        }

        function getCorrectPosition(value) {
            if (value === "") {
                return currentSize * currentSize - 1;
            }
            return parseInt(value) - 1;
        }

        function renderBoard() {
            const board = document.getElementById("board");
            board.innerHTML = "";
            tilesArray.forEach((num, index) => {
                const tile = document.createElement("div");
                tile.classList.add("tile");
                tile.textContent = num;
                tile.dataset.value = num;

                if (num === "") {
                    tile.classList.add("empty");
                } else {
                    const correctPosition = getCorrectPosition(num);
                    if (index === correctPosition) {
                        tile.classList.add("correct-position");
                    } else {
                        tile.classList.remove("correct-position");
                    }
                }

                board.appendChild(tile);
            });
        }

        function isSolvable(tilesArray, size) {
            if (tilesArray.length !== size * size) {
                console.error("O tamanho do array tilesArray n√£o corresponde ao tamanho do tabuleiro.");
                return false;
            }
            const tiles = tilesArray.filter(tile => tile !== ""); // Remove o espa√ßo vazio
            let inversions = 0;

            for (let i = 0; i < tiles.length; i++) {
                for (let j = i + 1; j < tiles.length; j++) {
                    if (parseInt(tiles[i]) > parseInt(tiles[j])) {
                        inversions++;
                    }
                }
            }

            if (size % 2 !== 0) {
                // Para tabuleiros de tamanho √≠mpar, o n√∫mero de invers√µes deve ser par
                return inversions % 2 === 0;
            } else {
                // Para tabuleiros de tamanho par, a posi√ß√£o da linha do espa√ßo vazio tamb√©m importa
                const emptyRow = Math.floor(tilesArray.indexOf("") / size);
                return (inversions % 2 === 0) === (emptyRow % 2 !== 0);
            }
        }

        function shuffleBoard() {
            let isValid = false;
            let attempts = 0;
            const maxAttempts = 100; // Limite de tentativas

            while (!isValid && attempts < maxAttempts) {
                attempts++;
                const numMoves = 1000;
                for (let i = 0; i < numMoves; i++) {
                    const emptyIndex = tilesArray.indexOf("");
                    const row = Math.floor(emptyIndex / currentSize);
                    const col = emptyIndex % currentSize;

                    const possibleMoves = [];
                    if (row > 0) possibleMoves.push(emptyIndex - currentSize);
                    if (row < currentSize - 1) possibleMoves.push(emptyIndex + currentSize);
                    if (col > 0) possibleMoves.push(emptyIndex - 1);
                    if (col < currentSize - 1) possibleMoves.push(emptyIndex + 1);

                    const randomIndex = Math.floor(Math.random() * possibleMoves.length);
                    const swapIndex = possibleMoves[randomIndex];

                    [tilesArray[emptyIndex], tilesArray[swapIndex]] = [tilesArray[swapIndex], tilesArray[emptyIndex]];
                }

                isValid = isSolvable(tilesArray, currentSize);
            }

            if (!isValid) {
                console.error("N√£o foi poss√≠vel gerar um tabuleiro solucion√°vel ap√≥s v√°rias tentativas.");
            }

            renderBoard();
        }

        function findEmptyPositionIndex() {
            return tilesArray.indexOf("");
        }

        function getTileIndex(tileElement) {
            return Array.from(tileElement.parentNode.children).indexOf(tileElement);
        }

        function getRowCol(index) {
            const row = Math.floor(index / currentSize);
            const col = index % currentSize;
            return { row, col };
        }

        function handleTileClick(event) {
            const clickedTile = event.target;
            if (!clickedTile.classList.contains('tile') || clickedTile.classList.contains('empty')) return;

            if (!isPaused && !gameWon) {
                const clickedIndex = getTileIndex(clickedTile);
                const emptyIndex = findEmptyPositionIndex();

                const clickedPos = getRowCol(clickedIndex);
                const emptyPos = getRowCol(emptyIndex);

                let moved = false;

                if (clickedPos.row === emptyPos.row || clickedPos.col === emptyPos.col) {
                    moved = moveLineOrColumn(clickedIndex, emptyIndex);
                }

                if (moved && !gameStarted) {
                    gameStarted = true;
                    startTimer();
                }

                if (moved) {
                    moveCount++;
                    document.getElementById("moveCounter").textContent = moveCount;
                    renderBoard();
                    checkWin();
                }
            }
        }

        function moveLineOrColumn(clickedIndex, emptyIndex) {
            const clickedPos = getRowCol(clickedIndex);
            const emptyPos = getRowCol(emptyIndex);
            const tempTilesArray = [...tilesArray];
            let moved = false;

            if (clickedPos.row === emptyPos.row) {
                const row = clickedPos.row;
                const start = Math.min(clickedIndex, emptyIndex);
                const end = Math.max(clickedIndex, emptyIndex);
                const tilesToMove = [];
                const direction = clickedIndex < emptyIndex ? 1 : -1;

                let currentIndex = clickedIndex;
                while (currentIndex !== emptyIndex) {
                    tilesToMove.push(tempTilesArray[currentIndex]);
                    currentIndex += direction;
                }

                currentIndex = emptyIndex;
                while (currentIndex !== clickedIndex) {
                    tempTilesArray[currentIndex] = tilesToMove.pop();
                    currentIndex -= direction;
                }
                tempTilesArray[clickedIndex] = "";
                moved = true;

            } else if (clickedPos.col === emptyPos.col) {
                const col = clickedPos.col;
                const start = Math.min(clickedIndex, emptyIndex);
                const end = Math.max(clickedIndex, emptyIndex);
                const tilesToMove = [];
                const direction = clickedIndex < emptyIndex ? currentSize : -currentSize;

                let currentIndex = clickedIndex;
                while (currentIndex !== emptyIndex) {
                    tilesToMove.push(tempTilesArray[currentIndex]);
                    currentIndex += direction;
                }

                currentIndex = emptyIndex;
                while (currentIndex !== clickedIndex) {
                    tempTilesArray[currentIndex] = tilesToMove.pop();
                    currentIndex -= direction;
                }
                tempTilesArray[clickedIndex] = "";
                moved = true;
            }

            if (moved) {
                tilesArray = tempTilesArray;
                return true;
            }
            return false;
        }

        function togglePause() {
            if (!gameStarted) {
                console.warn("O jogo ainda n√£o come√ßou.");
                return;
            }
            const board = document.getElementById("board");
            const pauseBtn = document.getElementById("pauseBtn");
            isPaused = !isPaused;
            board.classList.toggle("paused", isPaused);
            pauseBtn.textContent = isPaused ? "Continuar" : "Pausa";

            if (isPaused) {
                clearInterval(timerInterval);
                accumulatedTime += Date.now() - startTime; // Atualiza o tempo acumulado
            } else if (gameStarted) {
                startTimer();
            }
        }

        function confirmChange(size) {
            if (!gameStarted) {
                generateBoard(size);
            } else {
                showConfirmationOverlay(
                    "Tem certeza que deseja mudar para o tabuleiro " + size + "x" + size + "? Seu progresso atual ser√° perdido.",
                    () => { // Fun√ß√£o a ser executada se o usu√°rio clicar em "Sim"
                        generateBoard(size);
                    }
                );
            }
        }

        function confirmRestart() {
            if (!gameStarted) {
                generateBoard(currentSize);
            } else {
                showConfirmationOverlay(
                    "Tem certeza que deseja reiniciar o jogo? Seu progresso atual ser√° perdido.",
                    () => { // Fun√ß√£o a ser executada se o usu√°rio clicar em "Sim"
                        generateBoard(currentSize);
                    }
                );
            }
        }

        function showConfirmationOverlay(message, onConfirm) {
            let wasTimerRunning = gameStarted && !isPaused;

            clearInterval(timerInterval);
            if (gameStarted && !isPaused) {
                accumulatedTime += Date.now() - startTime; // Atualiza o tempo acumulado
            }

            const confirmationOverlay = document.createElement('div');
            confirmationOverlay.classList.add('win-overlay');

            const confirmationMessage = document.createElement('div');
            confirmationMessage.classList.add('win-message');

            const title = document.createElement('h2');
            title.textContent = "Confirma√ß√£o";

            const text = document.createElement('p');
            text.textContent = message;

            const confirmButton = document.createElement('button');
            confirmButton.classList.add('play-again-btn');
            confirmButton.textContent = "Sim";
            confirmButton.onclick = () => {
                onConfirm();
                confirmationOverlay.remove();
                if (gameStarted) {
                    resetTimer();
                }
            };

            const cancelButton = document.createElement('button');
            cancelButton.classList.add('play-again-btn');
            cancelButton.textContent = "N√£o";
            cancelButton.onclick = () => {
                confirmationOverlay.remove();
                if (wasTimerRunning) {
                    startTimer();
                }
            };

            confirmationMessage.appendChild(title);
            confirmationMessage.appendChild(text);
            confirmationMessage.appendChild(confirmButton);
            confirmationMessage.appendChild(cancelButton);
            confirmationOverlay.appendChild(confirmationMessage);
            document.body.appendChild(confirmationOverlay);

            setTimeout(() => {
                confirmationOverlay.classList.add('active');
            }, 10);
        }

        let accumulatedTime = 0;

        function startTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            startTime = Date.now();
            clearInterval(timerInterval);

            timerInterval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const totalElapsed = elapsed + accumulatedTime; // Adiciona o tempo acumulado
                const minutes = String(Math.floor(totalElapsed / 60000)).padStart(2, "0");
                const seconds = String(Math.floor((totalElapsed % 60000) / 1000)).padStart(2, "0");
                const milliseconds = String(totalElapsed % 1000).padStart(3, "0");

                document.getElementById("timer").textContent = `${minutes}:${seconds}:${milliseconds}`;
            }, 10);
        }

        function resetTimer() {
            clearInterval(timerInterval);
            document.getElementById("timer").textContent = "00:00:000";
        }

        function checkWin() {
            if (gameWon) return; // Evita reexecu√ß√£o desnecess√°ria
            const solvedBoard = [];
            for (let i = 1; i < currentSize * currentSize; i++) {
                solvedBoard.push(String(i));
            }
            solvedBoard.push("");

            let hasWon = true;
            for (let i = 0; i < tilesArray.length; i++) {
                if (tilesArray[i] !== solvedBoard[i]) {
                    hasWon = false;
                    break;
                }
            }

            console.log('Tabuleiro Solucionado Esperado:', solvedBoard);
            console.log('Tabuleiro Atual:', tilesArray);

            if (hasWon) {
                console.log('Vit√≥ria DETECTADA!');
                gameWon = true; // Define a flag de vit√≥ria
                clearInterval(timerInterval);
                const finalTime = document.getElementById("timer").textContent;
                saveScore(currentSize, moveCount, finalTime);
                updateScoreboardDisplay();

                mostrarTelaDeVitoria(finalTime);
            } else {
                console.log('Ainda n√£o venceu.');
            }
        }

        function mostrarTelaDeVitoria(finalTime) {
            const winOverlay = document.createElement('div');
            winOverlay.classList.add('win-overlay');

            const winMessage = document.createElement('div');
            winMessage.classList.add('win-message');

            winMessage.innerHTML = `
            <h2>Voc√™ Venceu!</h2>
            <p>Movimentos: ${moveCount}</p>
            <p>Tempo: ${finalTime}</p>
            <button class="play-again-btn" onclick="reiniciarJogo()">Jogar Novamente</button>
        `;

            winOverlay.appendChild(winMessage);
            document.body.appendChild(winOverlay);

            setTimeout(() => {
                winOverlay.classList.add('active');
            }, 10);

            document.getElementById("board").classList.add('game-over');
        }

        function reiniciarJogo() {
            const existingOverlay = document.querySelector('.win-overlay');
            if (existingOverlay) {
                existingOverlay.remove();
            }
            generateBoard(currentSize);
        }

        function toggleDarkMode() {
            const body = document.body;
            body.classList.toggle('dark-mode');

            const darkModeButton = document.querySelector('.theme-toggle-btn');
            if (body.classList.contains('dark-mode')) {
                darkModeButton.textContent = "Modo Claro";
            } else {
                darkModeButton.textContent = "Modo Escuro";
            }
        }

        document.addEventListener("DOMContentLoaded", () => {
            generateBoard(4);
            updateScoreboardDisplay();
        });
    </script>
</body>

</html>